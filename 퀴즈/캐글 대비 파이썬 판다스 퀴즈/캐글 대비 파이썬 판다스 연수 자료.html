<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>캐글 대비 파이썬/판다스 중급 학습 문제</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 20px;
            background-color: #f4f7f6;
            color: #333;
        }
        .container {
            max-width: 900px;
            margin: auto;
            background: #fff;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
        }
        h1 {
            color: #007bff;
            text-align: center;
            border-bottom: 3px solid #007bff;
            padding-bottom: 10px;
            margin-bottom: 30px;
        }
        .problem {
            background-color: #e9ecef;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 25px;
            border-left: 5px solid #007bff;
        }
        .problem h2 {
            color: #007bff;
            margin-top: 0;
            font-size: 1.5em;
        }
        .hint {
            color: #6c757d;
            font-style: italic;
            margin-top: 10px;
            font-size: 0.9em;
        }
        .solution-toggle {
            background-color: #28a745;
            color: white;
            border: none;
            padding: 8px 15px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 14px;
            margin-top: 10px;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        .solution-toggle:hover {
            background-color: #218838;
        }
        .solution-content {
            display: none;
            margin-top: 15px;
            padding: 15px;
            background-color: #f8f9fa;
            border: 1px dashed #ccc;
            border-radius: 5px;
            white-space: pre-wrap; /* 코드 줄바꿈 유지 */
        }
        .answer-label {
            font-weight: bold;
            color: #dc3545;
            margin-top: 10px;
            display: block;
        }
        .explanation-label {
            font-weight: bold;
            color: #007bff;
            margin-top: 10px;
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🏆 캐글 대비 파이썬/판다스 중급 분류 학습 문제 20제</h1>

        <div class="problem" id="q1">
            <h2>문제 1: Multi-Index 데이터프레임을 생성하고 인덱스 레벨을 초기화하여 일반 컬럼으로 변환하시오.</h2>
            <p><strong>주어진 데이터:</strong></p>
            <pre>
import pandas as pd
data = {'A': [1, 2], 'B': [3, 4], 'C': [5, 6]}
index = pd.MultiIndex.from_tuples([('G1', 'S1'), ('G2', 'S2')], names=['Group', 'Subgroup'])
df = pd.DataFrame(data, index=index)
            </pre>
            <div class="hint">힌트: 인덱스를 초기화하는 메서드와 인플레이스(inplace) 옵션을 사용해보세요.</div>
            <button class="solution-toggle" onclick="toggleSolution('s1')">답 & 설명 보이기</button>
            <div class="solution-content" id="s1">
                <span class="answer-label">✅ 답 (코드):</span>
                <pre>
df_reset = df.reset_index()
print(df_reset)
                </pre>
                <span class="explanation-label">💡 설명:</span>
                <p><code>reset_index()</code> 메서드는 MultiIndex를 포함한 DataFrame의 인덱스를 초기화하고, 기존 인덱스 레벨들을 일반 컬럼(이름 포함)으로 변환합니다. 새로운 기본 정수 인덱스가 생성됩니다.</p>
            </div>
        </div>

        <div class="problem" id="q2">
            <h2>문제 2: 'Age' 컬럼의 결측치(NaN)를 해당 컬럼의 중앙값(Median)으로 대체하시오.</h2>
            <p><strong>주어진 데이터:</strong></p>
            <pre>
data = {'Age': [25, 30, None, 45, 30, None, 22], 'Fare': [10, 20, 15, 30, 10, 5, 12]}
df = pd.DataFrame(data)
            </pre>
            <div class="hint">힌트: <code>fillna()</code> 메서드와 <code>median()</code> 메서드를 결합하여 사용하세요.</div>
            <button class="solution-toggle" onclick="toggleSolution('s2')">답 & 설명 보이기</button>
            <div class="solution-content" id="s2">
                <span class="answer-label">✅ 답 (코드):</span>
                <pre>
median_age = df['Age'].median()
df['Age'].fillna(median_age, inplace=True)
print(df['Age'])
                </pre>
                <span class="explanation-label">💡 설명:</span>
                <p>결측치 처리(Imputation)는 중요합니다. <code>median()</code>은 이상치(Outlier)에 덜 민감하므로 평균(mean)보다 안전한 대푯값이 될 수 있습니다. <code>fillna()</code>를 사용하여 결측치를 계산된 중앙값으로 채웁니다.</p>
            </div>
        </div>

        <div class="problem" id="q3">
            <h2>문제 3: 'Score' 컬럼의 값이 80 이상인 행에 대해 'Grade' 컬럼의 값을 'A'로 설정하시오. (<code>loc</code> 사용)</h2>
            <p><strong>주어진 데이터:</strong></p>
            <pre>
df = pd.DataFrame({'Score': [75, 85, 90, 65, 80], 'Grade': ['C', 'B', 'A', 'D', 'B']})
            </pre>
            <div class="hint">힌트: 불리언 인덱싱과 <code>loc</code> 접근자를 사용하여 행과 컬럼을 동시에 지정합니다.</div>
            <button class="solution-toggle" onclick="toggleSolution('s3')">답 & 설명 보이기</button>
            <div class="solution-content" id="s3">
                <span class="answer-label">✅ 답 (코드):</span>
                <pre>
df.loc[df['Score'] >= 80, 'Grade'] = 'A'
print(df)
                </pre>
                <span class="explanation-label">💡 설명:</span>
                <p>Pandas에서 데이터프레임의 일부에 조건적으로 값을 할당할 때는 SettingWithCopyWarning을 피하기 위해 <code>.loc</code> 접근자를 사용하는 것이 모범 사례입니다. <code>df[조건]</code>을 먼저 사용하고 할당하면 예상치 못한 복사본에 할당될 수 있습니다.</p>
            </div>
        </div>

        <div class="problem" id="q4">
            <h2>문제 4: 'Color' 컬럼에 대해 One-Hot Encoding을 수행하시오. (<code>get_dummies</code> 사용)</h2>
            <p><strong>주어진 데이터:</strong></p>
            <pre>
df = pd.DataFrame({'Fruit': ['Apple', 'Banana', 'Apple', 'Orange'], 'Color': ['Red', 'Yellow', 'Green', 'Orange']})
            </pre>
            <div class="hint">힌트: 판다스의 더미 변수 생성 함수를 사용합니다.</div>
            <button class="solution-toggle" onclick="toggleSolution('s4')">답 & 설명 보이기</button>
            <div class="solution-content" id="s4">
                <span class="answer-label">✅ 답 (코드):</span>
                <pre>
df_encoded = pd.get_dummies(df, columns=['Color'], prefix='Color')
print(df_encoded)
                </pre>
                <span class="explanation-label">💡 설명:</span>
                <p><code>pd.get_dummies()</code>는 범주형 데이터를 기계 학습 모델이 이해할 수 있는 숫자형(0 또는 1) 형태로 변환합니다. <code>prefix</code>를 사용하여 새로 생성된 컬럼의 이름에 접두사를 붙여 가독성을 높였습니다.</p>
            </div>
        </div>

        <div class="problem" id="q5">
            <h2>문제 5: 'City'별 'Sales'의 합계와 평균을 동시에 계산하여 데이터프레임으로 출력하시오.</h2>
            <p><strong>주어진 데이터:</strong></p>
            <pre>
data = {'City': ['Seoul', 'Busan', 'Seoul', 'Busan', 'Seoul'], 'Sales': [100, 150, 120, 200, 80]}
df = pd.DataFrame(data)
            </pre>
            <div class="hint">힌트: <code>groupby()</code> 후 <code>agg()</code> 메서드에 리스트를 전달합니다.</div>
            <button class="solution-toggle" onclick="toggleSolution('s5')">답 & 설명 보이기</button>
            <div class="solution-content" id="s5">
                <span class="answer-label">✅ 답 (코드):</span>
                <pre>
result = df.groupby('City')['Sales'].agg(['sum', 'mean'])
print(result)
                </pre>
                <span class="explanation-label">💡 설명:</span>
                <p><code>groupby()</code>는 그룹별 연산을 위한 핵심 기능입니다. <code>agg()</code>에 계산하고 싶은 집계 함수 이름(문자열)의 리스트를 전달하면 여러 통계량을 한 번에 계산할 수 있습니다.</p>
            </div>
        </div>

        <div class="problem" id="q6">
            <h2>문제 6: 'Price' 컬럼의 값들에 대해 $\text{log}(x+1)$ 변환을 적용하시오.</h2>
            <p><strong>주어진 데이터:</strong></p>
            <pre>
import numpy as np
df = pd.DataFrame({'Price': [10, 50, 100, 5, 200]})
            </pre>
            <div class="hint">힌트: <code>apply()</code> 메서드와 NumPy의 <code>log1p</code> 함수를 사용합니다.</div>
            <button class="solution-toggle" onclick="toggleSolution('s6')">답 & 설명 보이기</button>
            <div class="solution-content" id="s6">
                <span class="answer-label">✅ 답 (코드):</span>
                <pre>
df['Log_Price'] = df['Price'].apply(np.log1p)
print(df[['Price', 'Log_Price']])
                </pre>
                <span class="explanation-label">💡 설명:</span>
                <p><code>np.log1p(x)</code>는 $\text{log}(1+x)$를 계산하여, 특히 값이 0에 가까울 때 정밀도를 높여줍니다. 데이터의 분포를 정규화(Normalization)하여 모델의 성능을 개선할 때 유용합니다. Series에 <code>apply()</code>를 사용하여 개별 요소에 함수를 적용했습니다.</p>
            </div>
        </div>

        <div class="problem" id="q7">
            <h2>문제 7: 'ID'를 기준으로 두 데이터프레임을 이너 조인(Inner Join)하여 병합하시오.</h2>
            <p><strong>주어진 데이터:</strong></p>
            <pre>
df1 = pd.DataFrame({'ID': [1, 2, 3], 'Name': ['A', 'B', 'C']})
df2 = pd.DataFrame({'ID': [2, 3, 4], 'Salary': [500, 600, 700]})
            </pre>
            <div class="hint">힌트: <code>pd.merge()</code> 함수와 <code>how</code> 매개변수를 사용합니다.</div>
            <button class="solution-toggle" onclick="toggleSolution('s7')">답 & 설명 보이기</button>
            <div class="solution-content" id="s7">
                <span class="answer-label">✅ 답 (코드):</span>
                <pre>
merged_df = pd.merge(df1, df2, on='ID', how='inner')
print(merged_df)
                </pre>
                <span class="explanation-label">💡 설명:</span>
                <p><code>pd.merge()</code>는 SQL의 JOIN과 유사하게 작동합니다. <code>on='ID'</code>는 병합 기준 컬럼을 지정하고, <code>how='inner'</code>는 양쪽 데이터프레임에 모두 존재하는 키('ID' 값이 2, 3)만 남깁니다.</p>
            </div>
        </div>

        <div class="problem" id="q8">
            <h2>문제 8: 'Value' 컬럼에 대해 IQR(Interquartile Range) 방법을 사용하여 이상치(Outlier)를 제거하시오. (단, $Q1 - 1.5 \times IQR$ 보다 작거나 $Q3 + 1.5 \times IQR$ 보다 큰 값)</h2>
            <p><strong>주어진 데이터:</strong></p>
            <pre>
df = pd.DataFrame({'Value': [10, 12, 15, 18, 20, 100, 11]})
            </pre>
            <div class="hint">힌트: <code>quantile()</code> 메서드를 사용하여 $Q1$과 $Q3$를 계산하고 마스킹(Masking)을 사용합니다.</div>
            <button class="solution-toggle" onclick="toggleSolution('s8')">답 & 설명 보이기</button>
            <div class="solution-content" id="s8">
                <span class="answer-label">✅ 답 (코드):</span>
                <pre>
Q1 = df['Value'].quantile(0.25)
Q3 = df['Value'].quantile(0.75)
IQR = Q3 - Q1
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

df_filtered = df[(df['Value'] >= lower_bound) & (df['Value'] <= upper_bound)]
print(df_filtered)
                </pre>
                <span class="explanation-label">💡 설명:</span>
                <p>IQR 기반 이상치 제거는 데이터 전처리에서 흔히 사용됩니다. $Q1$ (1사분위수), $Q3$ (3사분위수)를 구하고 IQR 공식($Q3 - Q1$)을 사용하여 범위를 설정한 후, 불리언 인덱싱을 이용해 조건에 맞는 행만 추출합니다.</p>
            </div>
        </div>

        <div class="problem" id="q9">
            <h2>문제 9: 'A'와 'B' 컬럼의 합이 100 이상이면 'High'를, 아니면 'Low'를 값으로 가지는 'Level' 컬럼을 새로 생성하시오.</h2>
            <p><strong>주어진 데이터:</strong></p>
            <pre>
df = pd.DataFrame({'A': [50, 40, 60, 70], 'B': [60, 50, 30, 20]})
            </pre>
            <div class="hint">힌트: 데이터프레임의 행(row) 단위로 접근하는 <code>apply(axis=1)</code>과 <code>lambda</code> 함수를 사용합니다.</div>
            <button class="solution-toggle" onclick="toggleSolution('s9')">답 & 설명 보이기</button>
            <div class="solution-content" id="s9">
                <span class="answer-label">✅ 답 (코드):</span>
                <pre>
df['Level'] = df.apply(lambda row: 'High' if (row['A'] + row['B']) >= 100 else 'Low', axis=1)
print(df)
                </pre>
                <span class="explanation-label">💡 설명:</span>
                <p><code>axis=1</code>은 <code>apply</code> 메서드가 열이 아닌 행 단위로 작동하도록 지시합니다. <code>lambda row: ...</code>를 통해 각 행을 입력으로 받아 'A'와 'B'의 합계를 기준으로 조건부 로직을 실행할 수 있습니다.</p>
            </div>
        </div>

        <div class="problem" id="q10">
            <h2>문제 10: 'Product'를 인덱스로, 'Region'을 컬럼으로 하고 'Sales'의 평균을 값으로 하는 피벗 테이블을 생성하시오.</h2>
            <p><strong>주어진 데이터:</strong></p>
            <pre>
data = {'Product': ['A', 'B', 'A', 'B', 'A'], 'Region': ['East', 'West', 'East', 'West', 'West'], 'Sales': [10, 20, 15, 25, 30]}
df = pd.DataFrame(data)
            </pre>
            <div class="hint">힌트: <code>pd.pivot_table()</code> 함수를 사용합니다.</div>
            <button class="solution-toggle" onclick="toggleSolution('s10')">답 & 설명 보이기</button>
            <div class="solution-content" id="s10">
                <span class="answer-label">✅ 답 (코드):</span>
                <pre>
pivot_table = pd.pivot_table(df, values='Sales', index='Product', columns='Region', aggfunc='mean')
print(pivot_table)
                </pre>
                <span class="explanation-label">💡 설명:</span>
                <p>피벗 테이블은 데이터를 요약하고 특정 기준으로 교차 분석할 때 유용합니다. <code>aggfunc='mean'</code>은 기본값이지만, 여기서는 명시적으로 평균을 계산하도록 지정했습니다. 행(index)과 열(columns)의 교차점에 'Sales'의 평균이 들어갑니다.</p>
            </div>
        </div>

        <div class="problem" id="q11">
            <h2>문제 11: 'Name' 컬럼에서 쉼표(`, `) 뒤의 성만 추출하여 'Surname' 컬럼으로 저장하시오.</h2>
            <p><strong>주어진 데이터:</strong></p>
            <pre>
df = pd.DataFrame({'Name': ['Kim, Jisoo', 'Park, Minho', 'Lee, Sena']})
            </pre>
            <div class="hint">힌트: 문자열 접근자 <code>.str</code>과 <code>split()</code>, 그리고 리스트 인덱싱을 사용합니다.</div>
            <button class="solution-toggle" onclick="toggleSolution('s11')">답 & 설명 보이기</button>
            <div class="solution-content" id="s11">
                <span class="answer-label">✅ 답 (코드):</span>
                <pre>
df['Surname'] = df['Name'].str.split(', ').str[0]
print(df)
                </pre>
                <span class="explanation-label">💡 설명:</span>
                <p>판다스 Series의 문자열 메서드는 <code>.str</code> 접근자를 통해 사용합니다. <code>split(', ')</code>으로 문자열을 분리하고, <code>.str[0]</code>을 사용하여 분리된 리스트의 첫 번째 요소(이 경우 성)만 선택합니다.</p>
            </div>
        </div>

        <div class="problem" id="q12">
            <h2>문제 12: 'Count' 컬럼을 정수형(int)에서 실수형(float)으로 변환하시오.</h2>
            <p><strong>주어진 데이터:</strong></p>
            <pre>
df = pd.DataFrame({'Count': [10, 20, 30], 'Price': [1.5, 2.5, 3.5]})
            </pre>
            <div class="hint">힌트: <code>astype()</code> 메서드를 사용합니다.</div>
            <button class="solution-toggle" onclick="toggleSolution('s12')">답 & 설명 보이기</button>
            <div class="solution-content" id="s12">
                <span class="answer-label">✅ 답 (코드):</span>
                <pre>
df['Count'] = df['Count'].astype(float)
print(df.dtypes)
                </pre>
                <span class="explanation-label">💡 설명:</span>
                <p>데이터 타입 변환은 메모리 효율성이나 특정 연산을 위해 필수적입니다. <code>astype()</code>을 사용하면 손쉽게 Series의 데이터 타입을 원하는 형식(<code>int</code>, <code>float</code>, <code>str</code>, <code>category</code> 등)으로 변경할 수 있습니다.</p>
            </div>
        </div>

        <div class="problem" id="q13">
            <h2>문제 13: 'Date' 컬럼에서 년도를 추출하여 'Year' 컬럼으로 저장하시오. (먼저 datetime 타입으로 변환 필요)</h2>
            <p><strong>주어진 데이터:</strong></p>
            <pre>
df = pd.DataFrame({'Date': ['2023-01-01', '2024-03-15', '2023-12-31']})
            </pre>
            <div class="hint">힌트: <code>pd.to_datetime()</code>으로 변환 후, <code>.dt</code> 접근자를 사용합니다.</div>
            <button class="solution-toggle" onclick="toggleSolution('s13')">답 & 설명 보이기</button>
            <div class="solution-content" id="s13">
                <span class="answer-label">✅ 답 (코드):</span>
                <pre>
df['Date'] = pd.to_datetime(df['Date'])
df['Year'] = df['Date'].dt.year
print(df)
                </pre>
                <span class="explanation-label">💡 설명:</span>
                <p>판다스는 시계열 데이터 처리에 강력하며, <code>.dt</code> 접근자를 통해 datetime 타입 컬럼의 년, 월, 일, 요일 등의 구성요소에 쉽게 접근할 수 있습니다.</p>
            </div>
        </div>

        <div class="problem" id="q14">
            <h2>문제 14: 'Category' 컬럼의 각 고유값의 상대 빈도수 (비율)를 계산하시오.</h2>
            <p><strong>주어진 데이터:</strong></p>
            <pre>
df = pd.DataFrame({'Category': ['A', 'B', 'A', 'C', 'B', 'A', 'A']})
            </pre>
            <div class="hint">힌트: <code>value_counts()</code> 메서드의 특정 매개변수를 사용합니다.</div>
            <button class="solution-toggle" onclick="toggleSolution('s14')">답 & 설명 보이기</button>
            <div class="solution-content" id="s14">
                <span class="answer-label">✅ 답 (코드):</span>
                <pre>
relative_counts = df['Category'].value_counts(normalize=True)
print(relative_counts)
                </pre>
                <span class="explanation-label">💡 설명:</span>
                <p><code>value_counts()</code>는 고유값별 빈도수를 반환합니다. 여기에 <code>normalize=True</code> 옵션을 추가하면, 전체 데이터 수에 대한 각 빈도수의 비율, 즉 상대 빈도수를 계산하여 반환합니다.</p>
            </div>
        </div>

        <div class="problem" id="q15">
            <h2>문제 15: 'Age' 컬럼을 4개의 동일한 빈도를 가지는 그룹으로 나누고('Young', 'Mid', 'Old', 'Senior'), 새 컬럼 'Age_Group'으로 만드시오.</h2>
            <p><strong>주어진 데이터:</strong></p>
            <pre>
df = pd.DataFrame({'Age': [15, 25, 30, 45, 55, 60, 20, 35]})
            </pre>
            <div class="hint">힌트: <code>pd.qcut()</code>을 사용하여 사분위수로 나누고, <code>labels</code> 인자를 사용합니다.</div>
            <button class="solution-toggle" onclick="toggleSolution('s15')">답 & 설명 보이기</button>
            <div class="solution-content" id="s15">
                <span class="answer-label">✅ 답 (코드):</span>
                <pre>
labels = ['Young', 'Mid', 'Old', 'Senior']
df['Age_Group'] = pd.qcut(df['Age'], q=4, labels=labels)
print(df[['Age', 'Age_Group']])
                </pre>
                <span class="explanation-label">💡 설명:</span>
                <p><code>pd.qcut()</code>은 데이터를 동일한 개수(빈도)의 구간으로 나눕니다 (Quantile-based Discretization). 이는 데이터가 특정 값에 치우쳐 있을 때 유용하며, <code>labels</code>를 통해 사용자 정의된 범주 이름을 지정할 수 있습니다.</p>
            </div>
        </div>

        <div class="problem" id="q16">
            <h2>문제 16: 'Gender' 컬럼의 'M'을 0으로, 'F'를 1로 매핑하여 'Gender_Encoded' 컬럼을 생성하시오. (<code>map</code> 사용)</h2>
            <p><strong>주어진 데이터:</strong></p>
            <pre>
df = pd.DataFrame({'Gender': ['M', 'F', 'F', 'M', 'F']})
            </pre>
            <div class="hint">힌트: 딕셔너리를 사용하여 <code>map()</code> 메서드를 적용합니다.</div>
            <button class="solution-toggle" onclick="toggleSolution('s16')">답 & 설명 보이기</button>
            <div class="solution-content" id="s16">
                <span class="answer-label">✅ 답 (코드):</span>
                <pre>
mapping = {'M': 0, 'F': 1}
df['Gender_Encoded'] = df['Gender'].map(mapping)
print(df)
                </pre>
                <span class="explanation-label">💡 설명:</span>
                <p><code>map()</code> 메서드는 Series의 각 값에 대해 딕셔너리에 정의된 매핑 작업을 수행합니다. 이는 Label Encoding의 간단한 형태로, 특히 두 개의 범주를 0과 1로 변환할 때 유용합니다.</p>
            </div>
        </div>

        <div class="problem" id="q17">
            <h2>문제 17: Multi-Index 데이터프레임에서 가장 안쪽 인덱스 레벨인 'Subgroup'을 삭제하시오.</h2>
            <p><strong>주어진 데이터:</strong></p>
            <pre>
index = pd.MultiIndex.from_tuples([('G1', 'S1'), ('G2', 'S2')], names=['Group', 'Subgroup'])
df = pd.DataFrame({'Data': [10, 20]}, index=index)
            </pre>
            <div class="hint">힌트: <code>droplevel()</code> 메서드와 레벨 이름을 사용합니다.</div>
            <button class="solution-toggle" onclick="toggleSolution('s17')">답 & 설명 보이기</button>
            <div class="solution-content" id="s17">
                <span class="answer-label">✅ 답 (코드):</span>
                <pre>
df_dropped = df.droplevel(level='Subgroup')
print(df_dropped)
                </pre>
                <span class="explanation-label">💡 설명:</span>
                <p><code>droplevel()</code>은 Multi-Index에서 특정 레벨(이름 또는 인덱스 번호)을 제거하여 인덱스의 차원을 낮춥니다. 이는 데이터 구조를 단순화할 때 사용됩니다.</p>
            </div>
        </div>

        <div class="problem" id="q18">
            <h2>문제 18: 'City' 컬럼의 고유값이 인덱스가 되도록 데이터프레임의 인덱스를 설정하시오. (<code>set_index</code> 사용)</h2>
            <p><strong>주어진 데이터:</strong></p>
            <pre>
df = pd.DataFrame({'City': ['Seoul', 'Busan', 'Incheon'], 'Population': [1000, 350, 250]})
            </pre>
            <div class="hint">힌트: <code>set_index()</code> 메서드를 사용합니다.</div>
            <button class="solution-toggle" onclick="toggleSolution('s18')">답 & 설명 보이기</button>
            <div class="solution-content" id="s18">
                <span class="answer-label">✅ 답 (코드):</span>
                <pre>
df_indexed = df.set_index('City')
print(df_indexed)
                </pre>
                <span class="explanation-label">💡 설명:</span>
                <p><code>set_index()</code>는 하나 이상의 기존 컬럼을 데이터프레임의 인덱스로 설정합니다. 인덱스는 데이터프레임의 행을 식별하는 데 사용되는 중요한 속성이며, 특정 데이터를 빠르게 찾을 때 유리합니다.</p>
            </div>
        </div>

        <div class="problem" id="q19">
            <h2>문제 19: 'Text' 컬럼에서 'Python' 또는 'R'이 포함된 행만 필터링하시오.</h2>
            <p><strong>주어진 데이터:</strong></p>
            <pre>
df = pd.DataFrame({'Text': ['I love Python', 'I love SQL', 'I love R', 'I love Java']})
            </pre>
            <div class="hint">힌트: <code>.str.contains()</code> 메서드와 정규 표현식(OR 조건)을 사용합니다.</div>
            <button class="solution-toggle" onclick="toggleSolution('s19')">답 & 설명 보이기</button>
            <div class="solution-content" id="s19">
                <span class="answer-label">✅ 답 (코드):</span>
                <pre>
df_filtered = df[df['Text'].str.contains('Python|R')]
print(df_filtered)
                </pre>
                <span class="explanation-label">💡 설명:</span>
                <p><code>.str.contains()</code>는 문자열에 특정 패턴이 포함되어 있는지 확인하는 불리언 Series를 반환합니다. 정규 표현식에서 <code>|</code>(pipe) 기호는 논리적 OR을 의미합니다. 이렇게 생성된 불리언 Series를 이용해 원본 데이터프레임을 필터링합니다.</p>
            </div>
        </div>

        <div class="problem" id="q20">
            <h2>문제 20: 'Sales' 컬럼을 기준으로 내림차순(Descending)으로, 그 후 'Profit' 컬럼을 기준으로 오름차순(Ascending)으로 정렬하시오.</h2>
            <p><strong>주어진 데이터:</strong></p>
            <pre>
df = pd.DataFrame({'Sales': [100, 100, 50, 200], 'Profit': [10, 5, 20, 15]})
            </pre>
            <div class="hint">힌트: <code>sort_values()</code>의 <code>by</code>와 <code>ascending</code> 인자에 리스트를 전달합니다.</div>
            <button class="solution-toggle" onclick="toggleSolution('s20')">답 & 설명 보이기</button>
            <div class="solution-content" id="s20">
                <span class="answer-label">✅ 답 (코드):</span>
                <pre>
df_sorted = df.sort_values(by=['Sales', 'Profit'], ascending=[False, True])
print(df_sorted)
                </pre>
                <span class="explanation-label">💡 설명:</span>
                <p><code>sort_values()</code>는 리스트로 정렬 기준 컬럼(<code>by</code>)과 각 컬럼에 적용할 정렬 순서(<code>ascending</code>)를 지정하여 다중 조건 정렬을 수행할 수 있습니다. <code>False</code>는 내림차순을, <code>True</code>는 오름차순을 의미합니다.</p>
            </div>
        </div>

    </div>

    <script>
        // 답과 설명을 토글하는 JavaScript 함수
        function toggleSolution(id) {
            var solution = document.getElementById(id);
            var button = document.querySelector(`#q${id.slice(1)} .solution-toggle`);
            if (solution.style.display === 'block') {
                solution.style.display = 'none';
                button.textContent = '답 & 설명 보이기';
                button.style.backgroundColor = '#28a745';
            } else {
                solution.style.display = 'block';
                button.textContent = '답 & 설명 숨기기';
                button.style.backgroundColor = '#dc3545';
            }
        }
    </script>
</body>
</html>